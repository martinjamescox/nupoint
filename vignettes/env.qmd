---
title: "Non-uniform point estimates with an environmental density gradient"
author: "Martin J. Cox"
format: 
  html:
    math: katex
editor: visual
vignette: >
  %\VignetteIndexEntry{Non-uniform point estimates with an environmental density gradient}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

# Introduction
The purpose of this vignette is to provide an example to enable users to estimate an environmental preference function from point transect survey data. To do this, we estimate the distribution of beaked whales cues as a function of depth, while simultaneously accounting for decreasing detectability of whale cues with range. We fit a variety of functional forms for cue distribution as a function of depth, using a half-normal form for for the detection function, and select the best model on the basis of AIC. Model adequacy is tested using a $\chi^2$ goodness-of-fit test. We illustrate interval and variance estimation using a non-parametric bootstrap. 
We start by loading the nupoint package and the environmental data gradient data:
```{r}
#| echo: true
#| label: loadPkg
library(nupoint)
data("nupoint_sightings")
```

# Example dataset description
The survey region is specified via a grid of Cartesian coordinate pairs `(x, y)` spanning the region in which we want to draw inference. The coordinates are oriented so that `y` runs perpendicularly from the observer offshore and `x` is perpendicular to `y`. Beaked whale cue prevalence is parameterised as a function of depth, `z(x, y)`, at `(x, y)` using a probability density function (pdf) `π_z(z)`. In order to convert a pdf specified in terms of `z` into one specified in terms of `(x, y)`, we need the derivative `∂z(x,y)/∂y` throughout the survey region. This is therefore one of the required inputs to the estimation function. The estimation function `nupoint.env.fit()` needs two kinds of data: 

1. ***Sightings data*** This is a data frame with a row for each sighting and columns `r`, `z` and `dzdy`, being the radial distance of the sighting from the observer, the depth at the location of the sightings, and `∂z(x,y)/∂y`, the derivative of depth with respect to offshore distance `y`, at the location of the sighting. 

2. ***Survey region data*** The data required here are matrices specifying the depth at every grid point in the survey region (`z`), the derivative `∂z(x,y)/∂y` at every grid point, and the radial distance from the observer (`r`) at every grid point. In addition, the bounds of the survey region and the range of depths in it are required. These are specified via the maximum absolute values of `x` and `y` and the lower and upper limits of depth, `z`. 

The data named sightings included in the nupoint package is a list object containing all of the above information. (see @tbl-descrip for sightings structure). In addition to example whale cue observations (n = `r nrow(sightings$sighting.mat)`), the data set also describes the survey region. See Arranz et al. (2013) for details of data acquisition. 
```{r}
#| label: tbl-descrip
#| echo: false
#| results: asis
#| tbl-cap: "Description of the sightings data set."
knitr::kable(
  data.frame(
    Name = c(
      "sighting.mat", "x.mat", "y.mat", "rd.mat", "z.mat",
      "zGradmat", "x", "y", "obsx", "obsy", "wx", "wy", "wz", "minz"
    ),
    Description = c(
      "Sightings data frame with columns x, y, r, z, dxdy and obs.period (see below)",
      "Matrix containing x-coordinates of every grid point in the survey region",
      "Matrix containing y-coordinates of every grid point in the survey region",
      "Matrix with radial distance to every grid point in the survey region",
      "Matrix containing depths of every grid point in the survey region",
      "Matrix containing (∂z/∂y) of every grid point in the survey region.",
      "Vector of unique x-values in x.mat",
      "Vector of unique y-values in y.mat",
      "Observer x-location (a single value).",
      "Observer y-location (a single value).",
      "Absolute value of maximum x",
      "Maximum y (distance offshore)",
      "Maximum depth in survey region.",
      "Minimum depth in survey region."
    ),
    stringsAsFactors = FALSE
  ),
  col.names = c("Name", "Description"),
  #caption = "Description of the sightings data set."
)
```
### Description of the sightings data set
Beaked whale observations (@tbl-sightings-summary) were collected by a shore based observer (at coordinates (`obs~x~,obs~y~`) equal to (4850, 0). Sighting position data (`x`, `y`, `r`), stored in the `sightings$sight.mat` were all observed from this location. 

```{r}
#| label: tbl-sightings-summary
#| tbl-cap: "Beaked whale sightings summary statistics"
#| echo: FALSE
knitr::kable(
  summary(sightings$sighting.mat),
  #caption = "Beaked whale sightings summary statistics.",
  #col.names = c("Observation Period", "Number of Observations"),
  #align = c("l", "r")
)
```

### Survey region description 
The survey region is defined using matrices (@tbl-descrip). `z.mat` is a matrix of seabed depths, with `NA` values defining regions which either cannot be surveyed (in this example land), or areas that exceed the truncation distances (@fig-survey-region). When defining a survey region, all matrices (`x.mat`, `y.mat`, `rd.mat`, `z.mat`,` zGradmat`; see @tbl-descrip) must have the same dimensions, and each element in a given matrix must share common spatial locations with other matrices.
```{r}
#| label: fig-survey-region
#| fig-cap: "Plan view of seabed depth in survey region (units: m). Sightings of whale cues are shown as black points, and the shore-based observer as a solid black semicircle on the x-axis. Data were taken from a subset of those used by Arranz et al. (2013)."
#| echo: false
fields::image.plot(x=sightings$x,y=sightings$y,z=sightings$z.mat,xlab='X',ylab='Y')
points(sightings$sighting.mat$x, sightings$sighting.mat$y, pch=19, col='black', cex=0.5)
points(sightings$obsx, sightings$obsy, pch=19, col='black', cex=6)
```
# Maximum likelihood estimation
We now use maximum likelihood to simultaneously estimate parameters, `φ`, for the depth preference function, `π~z~(z; φ)` and parameters, `Θ`, for the detection function, `g(r; Θ)`. By way of example, we will use a half-normal form for the de tection function (specified via `nupoint.env.fit` argument `det.form=‘HNORM’`), and select a depth preference from five candidate forms (specified via `nupoint.env.fit` argument `grad.form`): `‘NORM’` for normal; `‘LOGNORM’` for log-normal; `‘BETA’` for beta; `‘UNIFORM’` for uniform, `‘MNORM’` (with additional `nupoint.env.fit` argument `n= 2`) for a mixture of two normal distributions. 
The following code snippet is used to fit the normal depth preference form. Before we fit, we need to set the depth preference and detection functions (`norm.grad.type` and `norm.det.type`), and starting values for the parameters of both these functions (`norm.pars`), together with lower and upper bounds for the parameters (`norm.LB`, `norm.UB`): 

```{r}
#| label: fit-norm
#| echo: true
norm.grad.type <- "NORM" #seabed depth to cue relationship distribution shape.
norm.det.type <- "HNORM"
norm.pars <- c(1000,200,3000) #starting values for parameter vector to be estimated
#parameter vector to be estmated
 #[1] = normal depth preference function mean;
 #[2] = normal depth preference function standard error;
 #[3] = half-normal detection function standard error.
norm.LB <- c(-2000,1,1) #lower parameter space bound.
norm.UB <- c(10000,10000,10000) #upper parameter space bound.
nDist=NULL #not using MNORM
```

Finally we call the `nupoint.env.fit` function and simultaneously estimate the depth preference and detection function parameters:

```{r}
#| label: fit-norm-call
#| echo: true
#| 
norm.fit<-nupoint.env.fit(pars=norm.pars,
 z=sightings$sighting.mat$z,
 rd=sightings$sighting.mat$r,
 dzdy=sightings$sighting.mat$dzdy,
 z.mat=sightings$z.mat,
 dzdy.mat=sightings$zGradmat,
 rd.mat=sightings$rd.mat,
 minz=sightings$minz,
 wx=sightings$wx,
 wy=sightings$wy,
 wz=sightings$wz,
 grad.type=norm.grad.type,
 det.type=norm.det.type,
 n=nDist,lower.b=norm.LB,upper.b=norm.UB)
```

## AIC model selection 
We use AIC to chose a model from a candidate set of models. In the case of beaked whale cues, our candidate set of models for the prevalence of whale cues with depth, `π~z~(z)`, was: normal, log-normal, beta, uniform and a two mixture distribution comprising of two normals. We estimate using each of the candidate models and then compare AICs. 

### Beta 
We follow the same procedure of specifying the depth preference and de tection functions, as well as specifying the starting parameters and upper and lower parameter estimate bounds. 

```{r}
#| label: fit-beta-call
#| echo: true

beta.grad.type<-"BETA" #seabed depth to cue relationship distribution shape. 
beta.det.type<-"HNORM" 
beta.pars<-c(2,2,2200) #starting values for 
#parameter vector to be estmated 
#[1] = beta depth preference function log(mean); 
#[2] = beta depth preference function log(standard error); > #[3] = half-normal detection function standard error. 
beta.LB<-c(0.1,0.1,1) #lower parameter space bound. 
beta.UB<-c(20,20,10000) #upper parameter space bound. 
beta.fit<-nupoint.env.fit(pars=beta.pars, 
 z=sightings$sighting.mat$z, 
 rd=sightings$sighting.mat$r, 
 dzdy=sightings$sighting.mat$dzdy, 
 z.mat=sightings$z.mat, 
 dzdy.mat=sightings$zGradmat, 
 rd.mat=sightings$rd.mat, 
 minz=sightings$minz, 
 wx=sightings$wx, 
 wy=sightings$wy, 
 wz=sightings$wz, 
 grad.type=beta.grad.type, 
 det.type=beta.det.type, 
 n=nDist,lower.b=beta.LB,upper.b=beta.UB) 
```

### Uniform
Here we are only estimating the detectability, the depth preferemce function is uniform so we don't need to specify 
```{r}
#| label: fit-uniform-call
#| echo: true
#| 
unif.grad.type <- "UNIFORM" #seabed depth to cue relationship distribution shape.
unif.det.type <- "HNORM"
unif.pars <- 2200 # starting values for parameter vector to be estmated
unif.LB <- 100 #lower parameter space bound.
unif.UB <- 6000 #upper parameter space bound.
unif.fit <- nupoint.env.fit(pars=unif.pars,
 z=sightings$sighting.mat$z,
 rd=sightings$sighting.mat$r,
 dzdy=sightings$sighting.mat$dzdy,
 z.mat=sightings$z.mat,
 dzdy.mat=sightings$zGradmat,
 rd.mat=sightings$rd.mat,
 minz=sightings$minz,
 wx=sightings$wx,
 wy=sightings$wy,
 wz=sightings$wz,
 grad.type=unif.grad.type,
 det.type=unif.det.type,
 n=nDist,lower.b=unif.LB,upper.b=unif.UB)
```

### Log-normal
```{r}
#| label: fit-lognorm-call
#| echo: true

lnorm.grad.type <- "LOGNORM" #seabed depth to cue relationship distribution shape.
lnorm.det.type <- "HNORM"
lnorm.pars=c(7,0.5,2500) #starting values for
#parameter vector to be estmated
 #[1] = log-normal depth preference function log(mean);
 #[2] = log-normal depth preference function log(standard deviation);
 #[3] half-normal detection function standard deviation.
 lnorm.LB <- c(1,0.1,10) #lower parameter space bound.
 lnorm.UB <- c(20,10,10000) #upper parameter space bound.
 
 lnorm.fit <- nupoint.env.fit(pars=lnorm.pars,
 z=sightings$sighting.mat$z,
 rd=sightings$sighting.mat$r,
 dzdy=sightings$sighting.mat$dzdy,
 z.mat=sightings$z.mat,
 dzdy.mat=sightings$zGradmat,
 rd.mat=sightings$rd.mat,
 minz=sightings$minz,
 wx=sightings$wx,
 wy=sightings$wy,
 wz=sightings$wz,
 grad.type=lnorm.grad.type,
 det.type=lnorm.det.type,
 n=nDist,lower.b=lnorm.LB,upper.b=lnorm.UB)
```

Examining the parameter estimates, `φˆ` (parameter point estimates in the above output), shows that `log µ` is estimated at the upper bound of the parameter space, making the fit suspect, so the log-normal parametric form is excluded from further analysis. 

### Mixture of two normal distributions 
Specifying arguments for the `nupoint.env.fit` is a little more complex when using the normal mixture `grad.type=’MNORM’` environmental preference function, but there is only one more argument, `n`, which specifies the number of mixture distributions. We start by specifying the depth preference and detection functions:
```{r}
#| label: fit-mnorm-single
#| echo: true
det.type <- "HNORM"
sigma.r <- 3000 #half-normal standard deviation (sigma) detection function parameter
grad.type <- "MNORM" #seabed depth cue distribution shape.
nDist <- 2 #number of normal distributions in the normal mixture distribution.
```

We then assign a starting weight to each distribution in the mixture, `α`:
```{r}
#| label: fit-mnorm-call-alpha
#| echo: true
wt <- rep(1/nDist,nDist) #distribution weights (final element removed later)
```
We distribute mixture distribution means, μ, evenly along the environmental gradient:
```{r}
#| label: fit-mnorm-call-mu
#| echo: true
mu <- seq(sightings$minz,sightings$wz,length=nDist)
```
and assign an arbitrary `σ`= 300 m to each distribution.
```{r}
#| label: fit-mnorm-call-sigma
#| echo: true
sigma <- rep(300,nDist)
pars <- as.vector(matrix(c(mu,sigma,wt),ncol=nDist,byrow=TRUE))
```
The final element of the vector, `***α***`, the weight of the nth distribution in the mixture, is removed since:

$$
\alpha_n = 1 - \sum_{i=1}^{n-1} \alpha_i
$$
```{r}
#| label: fit-mnorm-call-pars-alpha
#| echo: true
pars <- c(pars[-length(pars)],sigma.r)
```
Finally, we assign lower and upper parameter space bounds. We start by specifying minima:
```{r}
#| label: fit-mnorm-call-bounds
#| echo: true
mumin <- rep(-2000,nDist) #minimum mean
sigmamin <- rep(1,nDist) #minimum sigma
alphamin <- rep(-15,nDist) #minimum alpha
sigma.rmin <- 1 #minimum detection function parameter
```
then combine the parameter space minima in a single vector:
```{r}
#| label: fit-mnorm-call-min-vec
#| echo: true
lower.b <- as.vector(matrix(c(mumin,sigmamin,alphamin),ncol=nDist,byrow=TRUE))
lower.b <- c(lower.b[-length(lower.b)],sigma.rmin) #remove nth weight
```
Next we specify maxima:
```{r}
#| label: fit-mnorm-call-max-upper
#| echo: true
mumax <- rep(5e+3,nDist) #maximum mean
sigmamax <- rep(1e+8,nDist) #maximum sigma
alphamax <- rep(15,nDist) #maximum alpha
sigma.rmax <- 1e+5 #maximum detection function parameter.
```
then combine the parameter space maxima in a single vector:
```{r}
#| label: fit-mnorm-call-upper2
#| echo: true
upper.b <- as.vector(matrix(c(mumax,sigmamax,alphamax),ncol=nDist,byrow=TRUE))
upper.b <- c(upper.b[-length(upper.b)],sigma.rmax) #remove nth weight
```
We can now fit the two normal mixture distribution using the above settings:
```{r}
#| label: fit-mnorm-call-fit
#| echo: true
#| warning: false
mn.environ.fit <- nupoint.env.fit(pars=pars,
 z=sightings$sighting.mat$z,
 rd=sightings$sighting.mat$r,
 dzdy=sightings$sighting.mat$dzdy,
 z.mat=sightings$z.mat,
 dzdy.mat=sightings$zGradmat,
 rd.mat=sightings$rd.mat,
 minz=sightings$minz,
 wx=sightings$wx,
 wy=sightings$wy,
 wz=sightings$wz,
 grad.type=grad.type,
 det.type=det.type,
 n=nDist,lower.b=lower.b,upper.b=upper.b)
```

Results of the AIC model selection(Table 3) show that the Normal distribution was optimum for explaining whale cue habitat preference.
```{r}
#| label: tbl-mod-AIC
#| tbl-cap: "AIC model selection results for whale cue prevelance with depth. From the four candidate models, the Normal distribution was optimum for describing whale cue preference with depth."
#| echo: FALSE

tab_aic<-data.frame(AIC=c(norm.fit$AIC,beta.fit$AIC,unif.fit$AIC,mn.environ.fit$AIC))
tab_aic$Model_name<-c("Normal","Beta","Uniform","2-normal mixture")
oo<-order(tab_aic$AIC)
tab_aic<-tab_aic[oo,]
tab_aic$dAIC<-tab_aic$AIC-tab_aic$AIC[1]
aic_wt=exp(-0.5 * tab_aic$dAIC)
tab_aic$aic_wt<-aic_wt/sum(aic_wt)
row.names(tab_aic)=tab_aic$Model_name
tab_aic<-tab_aic[,-2]
names(tab_aic)[3]<-"AIC weight"

knitr::kable(
  tab_aic,
  digits=2,
  #caption = "Beaked whale sightings summary statistics.",
  #col.names = c("Observation Period", "Number of Observations"),
  #align = c("l", "r")
)
```

# Goodness-of-fit test
The `nupoint.env.gof` function is used to calculate a one-dimensional $\chi^2$ goodness-of-fit test. The `nupoint.env.gof` function is available for all the environmental gradient functional forms. Here we calculate the one-dimensional goodness-of-fit statistic for the Normal form of the whale cue prevalence model. We selected Normal form under AIC @tbl-mod-AIC.

```{r}
#| label: fit-norm-gof
#| echo: true
#| output: false

GoF.norm <- nupoint.env.gof(pars=norm.fit$par,
 r.mat=sightings$rd.mat,
 z.mat=sightings$z.mat,
 minz=sightings$minz,
 wz=sightings$wz,
 z.obs=sightings$sighting.mat$z,
 grad.type=norm.grad.type,
 det.type=norm.det.type,
 intervals=13,
 plot=FALSE,
 dzdy.mat=sightings$zGradmat)

```

A graphical output of the goodness-of-fit results is available by changing the argument `plot=TRUE` in `nupoint.env.gof` function (@fig-norm-gof). The intervals argument `nupoint.env.gof()` can also be used to manually specify break points for the goodness-of-fit bin intervals, allowing for varying bin widths.

```{r}
#| label: fig-norm-gof
#| fig-cap: "Graphical display of one-dimensional χ2 goodness-of-fit test. The upper left panel is seabed depth, m. Upper right panel is the intervals over which observed whale cues are aggregated and expected sightings, under the normal model are calculated. The lower right panel is the expected percentage of detections, and lower right a histogram of observed sightings and expected sightings."
#| echo: false
#| message: false
#| warning: false
#| output: true

GoF.norm <- nupoint.env.gof(pars=norm.fit$par,
 r.mat=sightings$rd.mat,
 z.mat=sightings$z.mat,
 minz=sightings$minz,
 wz=sightings$wz,
 z.obs=sightings$sighting.mat$z,
 grad.type=norm.grad.type,
 det.type=norm.det.type,
 intervals=13,
 plot=TRUE,
 dzdy.mat=sightings$zGradmat)

```
